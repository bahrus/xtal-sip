[![Published on webcomponents.org](https://img.shields.io/badge/webcomponents.org-published-blue.svg)](https://www.webcomponents.org/element/bahrus/xtal-sip)

# \<xtal-sip\>

<a href="https://www.webcomponents.org/element/bahrus/xtal-sip/demo/index.html">Demo</a>

Dynamically "water" a custom element tag with the necessary dependency to sprout the tag from an inert seedling to a thing of beauty.  Dependency free.

NB:  This component suffers currently in terms of IDE and build support, especially compared to the Polymer supported [lazy-imports](https://github.com/Polymer/lazy-imports).

Importing the files needed for web components seems likely to become a lot more complicated.  Some references will come from bower_components, some from node_modules.  Some will be references to html files, others js files.  And the references are likely to be in a state of flux, as the [whims of elite developers](https://codeburst.io/the-javascript-modules-limbo-585eedbb182e) change.  Components will first migrate to node_modules (how will we explain to our grandkids that web components are node modules?).   As support for HTML Imports wanes, many  *.html files will be converted to *.js files, then to *.mjs files, then back to *.mhtml files, once the W3C Ents show some HTML love.  That will shortly be followed by converting them to *.wasm, followed by the Universal binary format that includes HTML, JS, CSS, WASM: *.xap.

This component, \<xtal-sip\>, is intended to "centralize the pain."  Keep the mappings between custom element tags and where to load the references for them all in one place.

The annoying thing about HTMLImports (and ES6 Modules for that matter) is that creating references for each referenced web component inside an HTML or JS file feels like tedius busy work -- for HTML files, one must go towards the top of the page (outside any templates) to add the reference, and typically the reference is just a trite formulaic derivative of the tag name itself.  E.g. \<paper-input\> => \<link rel="import" href="../paper-input/paper-input.html"\>, \<paper-checkbox\> => \<link rel="import" href="../paper-checkbox/paper-checkbox.html"\>.   And all these references add to the footprint of the application.

On top of that, leveraging a CDN when deploying [some of the] files to production could also be simplified by managing dependencies centrally.  Or maybe some components should only be activated in debug mode on the developer's workstation, but not deployed to production.

Another scenario is when raw HTML content containing web components is rendered inside a code-centric framework, like (P)react.  Not having a good solution to this scenario may partly explain why we are "throwing in the towel," pushing web components that might be 99% static markup, 1% JavaScript, to be packaged / coded entirely in JavaScript. Sad!  

What if the markup is generated by a server-side framework like asp.mvc or Java EE MVC, or PhP (or, yes, node, which currently falls in the "other" category of [popular web frameworks](https://trends.builtwith.com/framework))?  And suppose that server-side rendering is using web components to supplement the server-side generated HTML?  Although we are not supposed to use the PWA Hacker News site to ["compare the performance of one PWA to another"](https://hnpwa.com/), one can't help noticing that the fastest performing implementation is the one that uses [no JavaScript, other than the service worker](https://github.com/davideast/hnpwa-firebase). Clearly, this is an architecture we can't dismiss.  But creating the web component references in a different location from the custom element tags when using a server-side solution can be quite awkward in these scenarios.   

The bottom line is that the need for centralizing management of references is likely to increase significantly. 

That's where \<xtal-sip\> fits in.

Whether using HTML Imports, or simple JavaScript references, or ES6 Modules, there's a pretty good principle that we can assume regarding web components:  *Each web component will depend on only one top-level reference*.  (One small exception to that rule, at least in spirit, appears to be with components that depend on icon libraries, like paper-icon-button).  Of course, that reference file itself will likely specify multiple other references recursively, following standardized module conventions, which is all fine and good.  \<xtal-sip\> is meant for content-heavy, non reusable web compositions, as opposed to highly reusable web components. 

xtal-sip assumes that web sites will want to take advantage of the recent web standard that allows  [content to be preloaded](https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content).  

```html
<link rel="preload" href="..."> 
```

For performance reasons, it is beneficial to use these to preload all these references ahead of time.  Might as well build on this support to provide the mappings we need, and not repeat ourselves.

So what does xtal-sip add to the \<link rel="preload"\> functionality?

## Auto triggering based on tag name

```html
<link 
    rel="preload" 
    as="document" 
    href="//myCDN.com/@bower_components/polymer/paper-checkbox/paper-checkbox.html" 
    data-tag="paper-checkbox"
>
```

NB:  Currently, Chrome does not preload assets when as="document."  This seems like a bug to me, but [what do I know](https://bugs.chromium.org/p/chromium/issues/detail?id=593267)?  Attempting to work around this unexpected behavior by setting as="script" causes duplicate requests, which is probably worse. 

When \<xtal-sip\> encounters a \<paper-checkbox\> tag (how it encounters it will be discussed later), it will perform a hash lookup for link preload tags with attribute 'data-tag="paper-checkbox"', and it will formally load the reference.  

## Compact dependency preloading

It was mentioned above that listing all the elements with the same prefix can be boring and add to the footprint.

The markup below allows for more compact dependency.

```html
<link 
    rel-ish="preload"  
    as="document" 
    href="//myCDN.com/@bower_components/polymer/paper-{1}/paper-{1}.html" 
    data-tags="paper-checkbox,paper-input,paper-button"
>
```

This is a "fake" preload tag, that is used as the foundation for dynamically generating multiple valid preload tags.

For each tag name found in the data-tags attribute, that name is split using the dash "-" delimiter.  {1} refers to the split array, index = 1.

xtal-sip will "autoexpand" this, and dynamically create multiple genuine preload tags in the header where each file is listed explictly.

One could always use fake preload tags, even for single mappings, to be consistent.  But using the non standard preload tag causes a delay, because the xtal-sip web component needs to load first before the real preload tags become active.

Here's an even more aggressive example, that uses {0} and {1}:

```html
<link 
    rel-ish="preload" 
    as="document" 
    href="//myIoTServerRunningFromMyMicrowaveOven.com/npm/@polymer/{0}-{1}/{0}-{1}.html" 
    data-tags="paper-checkbox,paper-input,paper-button,iron-input">
>
```


## Preemptive loading

By default, xtal-sip doesn't add the live script or link import tag to the header until it actually spots such a custom element tag in the live markup that depends on that import (but we are adding such references to the link rel="preload" in order to reduce the delay when the live custom element is observed).  This allows us to stay on the conservative side and only load into memory what's really needed.

However, if preemptive loading is desired, add the data-preemptive attribute:

```html
<link 
    rel="preload" 
    as="document" 
    href="../bower_components/paper-checkbox/paper-checkbox.html" 
    data-tag="paper-checkbox" 
    data-preemptive
>
```

This preemptive loading could also be (temporarily?) useful to use for the common (for now?) scenario that 1)  The component follows the Polymer <3 approach of importing via HTML Imports, and 2)  Chrome (and possibly other browsers) don't recognize as="document".

## JIT preloading

On the other side of the spectrum, perhaps there are certain locales one is targeting, where we know they pay a high price for downloading unnecessary stuff.

The only benefit we want from this custom element, in that case, is to perform concise lookups between tag names and the dependency.  In this case, if you use the "fake" preload tag:

```html
<link 
    rel-ish="preload" ...>
```

add the following code in the original navigation path:

```html
<script>
    customElements.whenDefined('xtal-sip').then(()=>{
        // Look at the browser's geolocation, ip address, do a look up to their content provider,
        // then evaluate the pricing mechanism in place depending on the time of day.
        // Utilize the recently standardized mobileAccountInfo api, to check if they 
        // are getting close to hitting their monthly data limit
        const isPayingThroughTheNose = ... ;
        //Now let XtalSip know the answer
        customElements.get('xtal-sip').useJITLoading = isPayingThroughTheNose
    })
</script>
```


## Async loading

If the preload tag has attribute data-async, then live references will use async capabilities (async import, async script reference).

## Script references

```html
<link 
    rel="preload" 
    as="script" 
    type="module" 
    href="node_modules/platinimum-{1}/platinum-{1}.js" 
    platinum-sw
>
```
## Bundling

Some CDN's, [like jsdelivr](https://www.jsdelivr.com/features) allow you to combine multiple assets together with one http request.

> https://cdn.jsdelivr.net/combine/gh/jquery/jquery@3.2/dist/jquery.min.js,gh/twbs/bootstrap@3.3/dist/js/bootstrap.min.js

[Support](https://www.nginx.com/resources/wiki/modules/concat/) [is](https://code.google.com/archive/p/modconcat/) also available on some web servers.

One can also utilize build processes that generate bundled resources that contain definitions for multiple custom element tag names.

While xtal-sip doesn't do anything to help create these bundled resources, or build the url's needed for concatenated resource requests, it does check if it has already requested a request before for other tag names, and if so, doesn't reload that url.

## ES5 / HTTP/1 alternative references

One of the more complex pieces to consider is the issue of browsers that don't support ES6 classes, a cornerstone of web components.  And also, browsers / servers (or proxies) that don't support HTTP/2.  These should all be temporary problems, but unfortunately "temporary" could be several years.

I'm sure anyone reading this has thought about the "Give me a one-handed economist" conundrum of how best to package and serve all users optimally.  On the one hand, the simplest thing to do is assume that the browsers that support ES6 will also suppport HTTP/2, and just build a giant bundle for ES5, and treat those users separately.  On the other hand even HTTP/1 users would benefit from some code splitting / progressive enhancement caching.  On the third hand, even HTTP/2 benefits from some bundling, depending perhaps on the server, etc.

### Tie breaking

The goal of xtal-sip is to be flexible enough that developers can find a way to apply the best strategy for their use case.  Hopefully, the need for this kind of trade-off guesswork will diminish over time, so xtal-sip provides no ready-made solutions for this. 

Instead, what it provides is this:  Define multiple fake "rel-ish" preload link tags, that match the same custom element name.  The developer can define a static "tie breaker" function used by all instances of the xtal-sip element, that may take into account numerous factors in their environment to determine which one to use from the matching set.

```html
<script>
    customElements.whenDefined('xtal-sip').then(()=>{
        customElements.get('xta.-sip').tieBreaker = (tagName, candidates) =>{
            //put your complex trade-off logic here, that picks from the candidates array.
            return thisIsTheBestCandidate;
        }
    })

</script>

```

The argument "candidates" is an array of different link "rel-ish" preload tags.  The developer could add their own custom attributes to these link tags, which, combined with the browser type in play and other factors, could choose which of the overlapping references to use.

## Discovering custom elements that need watering


By default, if you irrigate some markup with an  /<xtal-sip/> tag, /<xtal-sip/> searches the vicinity of the tag (starting from its parent) for any instances of custom element tag names not yet registered, but expected to be used eventually.  While this achieves (hopefully) simple, low-maintenance markup as one is building an application, it can grow in cost as the number of tag references grows, and the size of the DOM tree to inspect grows in complexity.

### Explicit declaration

An optimizing step is supported, where you can list the specific tags that need loading for that view.  These can be added as the application matures, when the production deployment nears.

```html
<xtal-sip load="paper-input,iron-ajax"></xtal-sip>
```

### Programmatic import

If the sight of \<xtal-sip\>'s is unpleasant to see in the markup, an alternative way of explicitly declararing which tags should become active is to call the static method:

```JavaScript
customElements.get('xtal-sip').loadDependencies('paper-input,iron-ajax');
```

### List of features:

- [x] Auto triggering based on tag name.
- [x] Compact dependency loading.
- [x] Optional preemptive loading.
- [x] Explicit tag dependency listing for optimal performance.
- [x] Support async loading.
- [x] Tie breaking
- [ ] Just-in-time loading static property
- [x]  Explicit declaration
- [ ] For non async, specify whether to add a setTimeout before adding import tag (defaults to true)
- [ ] Support specific settings of how to import (async, etc)
- [x] Autogenerate .html references.
- [x] Autogenerate .js classic script references.
- [ ] Autogenerate ES6 module script references.
- [ ] Add some sort of TBD mechanism to help with builds / push strategies (suggestions welcome).
  





## Install the Polymer-CLI

First, make sure you have the [Polymer CLI](https://www.npmjs.com/package/polymer-cli) installed. Then run `polymer serve` to serve your element locally.

## Viewing Your Element

```
$ polymer serve
```

## Running Tests

```
$ polymer test
```

Your application is already set up to be tested via [web-component-tester](https://github.com/Polymer/web-component-tester). Run `polymer test` to run your application's test suite locally.
